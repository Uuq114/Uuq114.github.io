---
title: Elasticsearch 101
tags: [Elasticsearch]
copyright: true
date: 2023-05-25 17:03:11
updated: 2023-05-25 17:03:11
permalink:
categories: [搜索引擎]
description:
---



## 0x00 简介

Elasticsearch 是一个分布式的全文搜索引擎，可以近乎实时地存储、检索数据。ES 的底层基于 Lucene 全文信息检索工具包，另一个搜索系统 Solr 也是基于 Lucene 开发的。

* 倒排索引
* ES 对存储使用的优化
* ES 和 MySQL 的比较

<!-- more -->

## 0x01 ES 101

**倒排索引**

在谷歌等搜索引擎中，一种常见的搜索方式是根据关键词返回相关的文档，即`word => doc`。`doc => word`这种查询的索引被称为正向索引（forward index），那么`word => doc`这种查询的索引就叫做倒排索引（反向索引，inverted index）了。

```
DICTIONARY     =====>     DOC
ada						 [1,2,3]
bob                      [2]
```



**ES 的 Dictionary 优化**

除了保存最基本的`word => doc`的映射，为了加速`word`这一层的查询，Lucene 在`Dictionary`的左边加了一层“字典树”，通过字典树可以定位单词的块，再在块中用二分查找得到单词的位置。

> 引入字典树是为了在不把字典全部缓存到内存的前提下，也能加速查询单词
>
> 除了字典树，ES 还引入了FST（有限状态转换器，Finite State Transducers）来减少内存占用



**ES 的 Posting list 优化**

ES 最右边的一层 DOC，虽然只是一些文档 ID 数组，但是 ES 也在这里做了优化，优化的目标有：

* 节省磁盘空间
* 快速求交集、并集

节省磁盘空间：

* 存储 DOC ID 的增量 + 分块：从存储原始的文档列表，变成存储文档 ID 的增量，比如：

  ```
  [73, 300, 302, 332, 343, 372] =>
  [73, 227, 2, 30, 11, 29]
  ```

  因为 Lucene 是用 segment 存储数据的（最多存 65536 个 ID），每个 segment 被分成块，每个块最多存 256 个 ID，这样用增量存储后，可以用更少位数存数据

* 按需分配空间：在上面分块的基础上，检查每个块的最大值需要分配多少位，达到按需分配。比如`227`就需要8 位，`30`就需要 5 位

快速求交并集：

使用 bitmap，用位运算



**为什么 ES 不使用 B+ 树存储？**

B+ 树主要设计目的是减少搜索时访问磁盘的次数，而 Lucene 等搜索引擎设计的时候，追求的目标是倒排压缩率&倒排解压速度&倒排 Bool 运算速度。取倒排到内存运算的时候，是连续读取，时间开销和倒排的大小有关系，所以并不适合用 B+ 数。
同理 MySQL 等数据库使用索引的目的是快速定位某一行数据，若使用倒排这种线性化的数据结构存储数据，其查找的时候访问磁盘的次数会远大于使用 B+ 的数据库。



## 0x02 Sequel

后面可能从 ES 的使用方面再写一篇 post，介绍 ES 的索引、映射、分片、备份相关的